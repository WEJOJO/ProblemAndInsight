실력체크 - 레벨2

문제

1.
----------------------------------------------------------------------------------------------------------------------------------------------------------
Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.

1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15
자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.

제한사항
n은 10,000 이하의 자연수 입니다.

입출력 예
n	result
15	4
입출력 예 설명
입출력 예#1
문제의 예시와 같습니다.
----------------------------------------------------------------------------------------------------------------------------------------------------------





>>> 코딩 테스트의 문제는 수학적인 규칙성을 파악해서 푸는 것 보다는, 컴퓨터에게 단순하지만 반복적인 일을 전부 시켜서 뽑아내게 하는 것을 목적으로 하는 것이 아닐까 생각하게 된 문제이다...

풀기위해 고민했던 규칙성의 파악---> 파악시간:5시간 이상

어떤 자연수 n에 대해서 m개의 연속된 자연수로 표현할 수 있는 지 아닌지를 알려면, m의 케이스를 우선 분리해야한다
이유 : 홀/짝에 따라 규칙의 파악이 다르기 때문  >>> 홀수는 쉬움





Case - m이 짝수일 때,
a. 
n/m >>> m이 짝수인데, 몫이 딱 떨어지면, m개의 연속된 자연수는 존재하지 않음. 
::: ex: 16을 4로 나누면 4로 떨어지는데, 4 4 / 4 4 대칭점을 기준으로 +/- 나누어 줄 것이 없음. 가운데를 기준으로 -1/+1 하면 3 / 5로 연속되지 않음

b.
n/m의 나머지가 0.75등 0.5가 아니면 m개의 연속된 자연수는 마찬가지로 존재하지 않는다.
::: ex: 15의 4개조합이 존재하는지 확인 >> 3.75 / 3.75 // 3.75 / 3.75 총합이 15인 상태로 대칭을 이루려면 소수점을 떨어뜨려야하고, 이 소수점들도 대칭을 이뤄야 한다.
::: -0.75/+0.75를하면 3//4.5로 연속된 자연수 조건 탈락.
::: 연속된 자연수 조건을 이루려고 2/3//4/5 로 하면 총량이 14로 15에 미만한다. 마찬가지로 3/4//5/6을 하면 18로 15를 초과함

c. 나머지가 0.5여도 무조건 되는건 아니다.
::: ex: 15를 6으로 하는 경우, 2.5 / 2.5 / 2.5 // 2.5 / 2.5 / 2.5
::: 0.5를 +-해서 대칭을 이루는 경우 0 / 1 / 2 / 3 / 4 / 5 >>> 0이 있으므로 자연수 조건 탈락.

결국 좌항의 갯수가 몫값 n//m보다 작으면 안된다. 분모가되는 m을 2등분 한값이 좌항의 갯수가 됌
:::((m/2) < n//m) 예시에선 3 < 2(거짓) 이므로 6개의 연속된 수로는 표현할 수 없다

Case - m이 홀수 일 때
m이 홀수면 나머지가 없이 딱 떨어지면 무조건 표현가능함
평균값을 m번 나열하는데 홀수이므로 가운데 뺴고 대칭으로 +/-를 가해줄 수 있기 떄문에 대칭도 가능하기 떄문

최종결론 ::::: 결국 레벨2수준의 실력체크 문제에서 푸는사람에게 이렇게 복잡한 규칙성을 30분 내에 파악하라는 것은 출제 의도가 아닐터, 하나하나 다 컴퓨터에게 시켜서 풀도록 하는 것이 의도로 보인다.

:::::이런 수학적인 규칙을 발견하는데는 6시간 이상이 걸리나, 몇가지 규칙성만 가지고 컴퓨터에게 효율적으로 일을 시키는 방법을 고안하면 아래와같이 편하게 처리가능
----직접 작성한 코드----
def solution(n):
    #숫자별  최소값
    answer = 0

    def sum(m):
        i=1
        sum=0
        while i<=m:
            sum+=i
            i+=1
        return sum
    
    k=1
    while sum(k)<=n:
        if (n-sum(k))%k == 0:
            answer+=1
        k+=1
    return answer

1+2+3+4+5=15 > 와 같이 5개의 항으로 표현가능하면 다른 방식의 5항으로 표현하는 건 불가하다 >> 2+3+4+5+6==> 20 연속되게 다른걸 하려면 결국 총량이 변하기 때문
그럼 종결조건을 정해놓고서 1부터 시작해서 가능한 항의 갯수를 찾는다.

즉 1개의 항을 찾는다면 1 >>> 1을 1씩 증가시켜서 15를 만들수 있는가? yes
2개의 항을 찾는다면 1+2=3 >>> 15-3=12 >>> 항이 2개이므로 +1씩하면 총 +2가 된다 즉, 2씩 증가시켜서 12를 만들수 있는가? (나머지가 0인가?) yes 1+2 > 2+3 > 3+4 >>> 7+8=15
3개의 항 1+2+3 >>> 6 >>> 15-6=9 >>> 항이 3개이므로 +1씩하면 +3가된다. 3씩 증가시켜서 9를 만들 수 있는가? yes 1+2+3 > 2+3+4 > 3+4+5 > 4+5+6=15

이 방식으로 해결하면, p개의 항으로 표현될 수있는지 확인하려면
1부터 시작해서 1+2+3'''+p까지를 구하는 함수 sum을 만들고 (sum은  p개의 항으로 숫자를 표현할 수 있는 최솟값이된다 >>> 1부터 시작했기 때문에)
이 함수 sum으로부터 구해진 값이 n과 같으면 그대로 리턴, 더 작으면 +1씩해서 찾아야 하는데, 결국 p개의 항을 가지고 있으므로 +1씩 늘어나면 결국 총량이 +p 된다
:::::배수로 풀 수 있음 몫과 

그럼 n이 p개의 항으로 표현가능하려면 n에서 sum(p)뺀 값이 p로 나눠 떨어져야만 한다.
        if (n-sum(p))%p == 0:
            answer+=1

2.
----------------------------------------------------------------------------------------------------------------------------------------------------------
1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.

1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
이전에 등장했던 단어는 사용할 수 없습니다.
한 글자인 단어는 인정되지 않습니다.
다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.

tank → kick → know → wheel → land → dream → mother → robot → tank

위 끝말잇기는 다음과 같이 진행됩니다.

1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.
2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.
3번 사람이 자신의 첫 번째 차례에 know를 말합니다.
1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.
(계속 진행)
끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.

사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.

제한 사항
끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.
words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.
단어의 길이는 2 이상 50 이하입니다.
모든 단어는 알파벳 소문자로만 이루어져 있습니다.
끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.
정답은 [ 번호, 차례 ] 형태로 return 해주세요.
만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.

입출력 예
n	words	result
3	["tank", "kick", "know", "wheel", "land", "dream", "mother", "robot", "tank"]	[3,3]
5	["hello", "observe", "effect", "take", "either", "recognize", "encourage", "ensure", "establish", "hang", "gather", "refer", "reference", "estimate", "executive"]	[0,0]
2	["hello", "one", "even", "never", "now", "world", "draw"]	[1,3]
입출력 예 설명
입출력 예 #1
3명의 사람이 끝말잇기에 참여하고 있습니다.

1번 사람 : tank, wheel, mother
2번 사람 : kick, land, robot
3번 사람 : know, dream, tank
와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.

입출력 예 #2
5명의 사람이 끝말잇기에 참여하고 있습니다.

1번 사람 : hello, recognize, gather
2번 사람 : observe, encourage, refer
3번 사람 : effect, ensure, reference
4번 사람 : take, establish, estimate
5번 사람 : either, hang, executive
와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.

입출력 예 #3
2명의 사람이 끝말잇기에 참여하고 있습니다.

1번 사람 : hello, even, now, draw
2번 사람 : one, never, world
와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.
----------------------------------------------------------------------------------------------------------------------------------------------------------


내 작성 코드

def solution(n, words):
    answer = []
    i=0
    while i < len(words)-1:
        k=0
        b=True
        while k<i+1:
            if words[k] == words[i+1]:
                b=False
                #pp로 따로 놓고 대소비교를 해야할지는 좀 더 생각
            k+=1    
        if words[i][-1] == words[i+1][0] and b is True:
            i+=1 
        else:
            p=i+1
            answer.append((p%n)+1)
            answer.append((p//n)+1)
            return answer  
        
        
    answer=[0,0]
    return answer

----------------------------------------------------------------------------------------------------------------------------------------------------------
:::몫과 나머지를 이용하는 방식으로 풀면됨. 다만 조건이 2개라서 어떻게 이 둘을 버무려야할지가 고민이었는데, 2중 while 문을 통해서 한 번에 체크할 수 있도록 처리했음
30분 내에 끝을 냈어야 했으나 1시간 걸려서 처리함. >> 아직 머릿속에 있는 걸 구현해내는 능력이 떨어지는듯 집중력도 조금 떨어짐

다른 사람의 풀이
----------------------------------------------------------------------------------------------------------------------------------------------------------
def solution(n, words):
    for p in range(1, len(words)):
        if words[p][0] != words[p-1][-1] or words[p] in words[:p]: return [(p%n)+1, (p//n)+1]
    else:
        return [0,0]
----------------------------------------------------------------------------------------------------------------------------------------------------------
배워야 할 점 ::: words[p]로 배열의 값을 특정하였고, in words[:p]를 통해 전체배열의 슬라이싱해서 찾아서 코드도 단순했지만 복잡도도 전체를 뒤지는 게 아닌 방식으로 처리했다





