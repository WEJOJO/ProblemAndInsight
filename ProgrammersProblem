실력체크 - 레벨2

문제

1.
----------------------------------------------------------------------------------------------------------------------------------------------------------
Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.

1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15
자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.

제한사항
n은 10,000 이하의 자연수 입니다.

입출력 예
n	result
15	4
입출력 예 설명
입출력 예#1
문제의 예시와 같습니다.
----------------------------------------------------------------------------------------------------------------------------------------------------------





>>> 코딩 테스트의 문제는 수학적인 규칙성을 파악해서 푸는 것 보다는, 컴퓨터에게 단순하지만 반복적인 일을 전부 시켜서 뽑아내게 하는 것을 목적으로 하는 것이 아닐까 생각하게 된 문제이다...

풀기위해 고민했던 규칙성의 파악---> 파악시간:5시간 이상

어떤 자연수 n에 대해서 m개의 연속된 자연수로 표현할 수 있는 지 아닌지를 알려면, m의 케이스를 우선 분리해야한다
이유 : 홀/짝에 따라 규칙의 파악이 다르기 때문  >>> 홀수는 쉬움





Case - m이 짝수일 때,
a. 
n/m >>> m이 짝수인데, 몫이 딱 떨어지면, m개의 연속된 자연수는 존재하지 않음. 
::: ex: 16을 4로 나누면 4로 떨어지는데, 4 4 / 4 4 대칭점을 기준으로 +/- 나누어 줄 것이 없음. 가운데를 기준으로 -1/+1 하면 3 / 5로 연속되지 않음

b.
n/m의 나머지가 0.75등 0.5가 아니면 m개의 연속된 자연수는 마찬가지로 존재하지 않는다.
::: ex: 15의 4개조합이 존재하는지 확인 >> 3.75 / 3.75 // 3.75 / 3.75 총합이 15인 상태로 대칭을 이루려면 소수점을 떨어뜨려야하고, 이 소수점들도 대칭을 이뤄야 한다.
::: -0.75/+0.75를하면 3//4.5로 연속된 자연수 조건 탈락.
::: 연속된 자연수 조건을 이루려고 2/3//4/5 로 하면 총량이 14로 15에 미만한다. 마찬가지로 3/4//5/6을 하면 18로 15를 초과함

c. 나머지가 0.5여도 무조건 되는건 아니다.
::: ex: 15를 6으로 하는 경우, 2.5 / 2.5 / 2.5 // 2.5 / 2.5 / 2.5
::: 0.5를 +-해서 대칭을 이루는 경우 0 / 1 / 2 / 3 / 4 / 5 >>> 0이 있으므로 자연수 조건 탈락.

결국 좌항의 갯수가 몫값 n//m보다 작으면 안된다. 분모가되는 m을 2등분 한값이 좌항의 갯수가 됌
:::((m/2) < n//m) 예시에선 3 < 2(거짓) 이므로 6개의 연속된 수로는 표현할 수 없다

Case - m이 홀수 일 때
m이 홀수면 나머지가 없이 딱 떨어지면 무조건 표현가능함
평균값을 m번 나열하는데 홀수이므로 가운데 뺴고 대칭으로 +/-를 가해줄 수 있기 떄문에 대칭도 가능하기 떄문

최종결론 ::::: 결국 레벨2수준의 실력체크 문제에서 푸는사람에게 이렇게 복잡한 규칙성을 30분 내에 파악하라는 것은 출제 의도가 아닐터, 하나하나 다 컴퓨터에게 시켜서 풀도록 하는 것이 의도로 보인다.

:::::이런 수학적인 규칙을 발견하는데는 6시간 이상이 걸리나, 몇가지 규칙성만 가지고 컴퓨터에게 효율적으로 일을 시키는 방법을 고안하면 아래와같이 편하게 처리가능
----직접 작성한 코드----
def solution(n):
    #숫자별  최소값
    answer = 0

    def sum(m):
        i=1
        sum=0
        while i<=m:
            sum+=i
            i+=1
        return sum
    
    k=1
    while sum(k)<=n:
        if (n-sum(k))%k == 0:
            answer+=1
        k+=1
    return answer

1+2+3+4+5=15 > 와 같이 5개의 항으로 표현가능하면 다른 방식의 5항으로 표현하는 건 불가하다 >> 2+3+4+5+6==> 20 연속되게 다른걸 하려면 결국 총량이 변하기 때문
그럼 종결조건을 정해놓고서 1부터 시작해서 가능한 항의 갯수를 찾는다.

즉 1개의 항을 찾는다면 1 >>> 1을 1씩 증가시켜서 15를 만들수 있는가? yes
2개의 항을 찾는다면 1+2=3 >>> 15-3=12 >>> 항이 2개이므로 +1씩하면 총 +2가 된다 즉, 2씩 증가시켜서 12를 만들수 있는가? (나머지가 0인가?) yes 1+2 > 2+3 > 3+4 >>> 7+8=15
3개의 항 1+2+3 >>> 6 >>> 15-6=9 >>> 항이 3개이므로 +1씩하면 +3가된다. 3씩 증가시켜서 9를 만들 수 있는가? yes 1+2+3 > 2+3+4 > 3+4+5 > 4+5+6=15

이 방식으로 해결하면, p개의 항으로 표현될 수있는지 확인하려면
1부터 시작해서 1+2+3'''+p까지를 구하는 함수 sum을 만들고 (sum은  p개의 항으로 숫자를 표현할 수 있는 최솟값이된다 >>> 1부터 시작했기 때문에)
이 함수 sum으로부터 구해진 값이 n과 같으면 그대로 리턴, 더 작으면 +1씩해서 찾아야 하는데, 결국 p개의 항을 가지고 있으므로 +1씩 늘어나면 결국 총량이 +p 된다
:::::배수로 풀 수 있음 몫과 

그럼 n이 p개의 항으로 표현가능하려면 n에서 sum(p)뺀 값이 p로 나눠 떨어져야만 한다.
        if (n-sum(p))%p == 0:
            answer+=1

2.
----------------------------------------------------------------------------------------------------------------------------------------------------------
1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.

1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
이전에 등장했던 단어는 사용할 수 없습니다.
한 글자인 단어는 인정되지 않습니다.
다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.

tank → kick → know → wheel → land → dream → mother → robot → tank

위 끝말잇기는 다음과 같이 진행됩니다.

1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.
2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.
3번 사람이 자신의 첫 번째 차례에 know를 말합니다.
1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.
(계속 진행)
끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.

사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.

제한 사항
끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.
words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.
단어의 길이는 2 이상 50 이하입니다.
모든 단어는 알파벳 소문자로만 이루어져 있습니다.
끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.
정답은 [ 번호, 차례 ] 형태로 return 해주세요.
만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.

입출력 예
n	words	result
3	["tank", "kick", "know", "wheel", "land", "dream", "mother", "robot", "tank"]	[3,3]
5	["hello", "observe", "effect", "take", "either", "recognize", "encourage", "ensure", "establish", "hang", "gather", "refer", "reference", "estimate", "executive"]	[0,0]
2	["hello", "one", "even", "never", "now", "world", "draw"]	[1,3]
입출력 예 설명
입출력 예 #1
3명의 사람이 끝말잇기에 참여하고 있습니다.

1번 사람 : tank, wheel, mother
2번 사람 : kick, land, robot
3번 사람 : know, dream, tank
와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.

입출력 예 #2
5명의 사람이 끝말잇기에 참여하고 있습니다.

1번 사람 : hello, recognize, gather
2번 사람 : observe, encourage, refer
3번 사람 : effect, ensure, reference
4번 사람 : take, establish, estimate
5번 사람 : either, hang, executive
와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.

입출력 예 #3
2명의 사람이 끝말잇기에 참여하고 있습니다.

1번 사람 : hello, even, now, draw
2번 사람 : one, never, world
와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.
----------------------------------------------------------------------------------------------------------------------------------------------------------


내 작성 코드

def solution(n, words):
    answer = []
    i=0
    while i < len(words)-1:
        k=0
        b=True
        while k<i+1:
            if words[k] == words[i+1]:
                b=False
                #pp로 따로 놓고 대소비교를 해야할지는 좀 더 생각
            k+=1    
        if words[i][-1] == words[i+1][0] and b is True:
            i+=1 
        else:
            p=i+1
            answer.append((p%n)+1)
            answer.append((p//n)+1)
            return answer  
        
        
    answer=[0,0]
    return answer

----------------------------------------------------------------------------------------------------------------------------------------------------------
:::몫과 나머지를 이용하는 방식으로 풀면됨. 다만 조건이 2개라서 어떻게 이 둘을 버무려야할지가 고민이었는데, 2중 while 문을 통해서 한 번에 체크할 수 있도록 처리했음
30분 내에 끝을 냈어야 했으나 1시간 걸려서 처리함. >> 아직 머릿속에 있는 걸 구현해내는 능력이 떨어지는듯 집중력도 조금 떨어짐

다른 사람의 풀이
----------------------------------------------------------------------------------------------------------------------------------------------------------
def solution(n, words):
    for p in range(1, len(words)):
        if words[p][0] != words[p-1][-1] or words[p] in words[:p]: return [(p%n)+1, (p//n)+1]
    else:
        return [0,0]
----------------------------------------------------------------------------------------------------------------------------------------------------------
배워야 할 점 ::: words[p]로 배열의 값을 특정하였고, in words[:p]를 통해 전체배열의 슬라이싱해서 찾아서 코드도 단순했지만 복잡도도 전체를 뒤지는 게 아닌 방식으로 처리했다





3.
----------------------------------------------------------------------------------------------------------------------------------------------------------
124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.

124 나라에는 자연수만 존재합니다.
124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.
예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.

10진법	124 나라	10진법	124 나라
1	1	6	14
2	2	7	21
3	4	8	22
4	11	9	24
5	12	10	41
자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요.

제한사항
n은 500,000,000이하의 자연수 입니다.
입출력 예
n	result
1	1
2	2
3	4
4	11
----------------------------------------------------------------------------------------------------------------------------------------------------------

효율성 테스트 통과못한 내 풀이
def solution(n):
    answer = ''
    def sum(n):
        sum=0
        i=0
        while sum<=n:
            sum+=3**i
            i+=1
        return i-1,sum-(3**(i-1))
    
    q,ssum = sum(n)
    
    loop=3**q #총 시행 횟수
    #111이 숫자 몇인지 파악해야함
    #28번 반복문의 loop에서 그 숫자만큼 뺄거임

    #111 구하고 반복횟수만큼시행
    numAn = []

    for t in range(1,q+1):
        numAn.append(1)
    

    pp=1
    k=1
    while pp<n-ssum+1:
        if numAn[-k]==4:
            k+=1
        else:
            p=numAn[-k]*2
            numAn[-k]=p
            while k>1:
                k-=1
                numAn[-k]=1
            pp+=1

    for a in numAn:
        answer+=str(a)
    
    
    return answer

----------------------------------------------------------------------------------------------------------------------------------------------------------
ㄴ> 진법으로 접근하고 인덱싱으로 문자열을 바꾸지 못한다는 점을 들어 결국 배열로 하나하나 저장해서 인덱싱으로 바꾸는 방법을 선택했으나, 타겟을 너무 광범위하게 잡아 1억정도를 넣어도 11초정도가 걸리는
구린 코드가 되었음

스택으로 풀기에는 연산이 너무 많아져서 포기함 >> 거르는 눈이 필요함

----------------------------------------------------------------------------------------------------------------------------------------------------------
def solution(n):
    answer = ''
    def sum(n):
        sum=0
        i=0
        while sum<=n:
            sum+=3**i
            i+=1
        return i-2,sum-(3**(i-1))
    
    q,ssum = sum(n)
    
    loop=3**q #총 시행 횟수
    #38일 때 q의 값은 3이 아니라 2이길 바란다.. > 이 값 조정할 때 n=3 (한자리수) 으로 넣어도 정상동작 하는지 확인 필요
    base=ssum
    while q>=0:
        if base+2*(3**q) <= n:
            base=base+2*(3**q)
            answer+='4'
        elif base+3**q <=n:
            base=base+(3**q)
            answer+='2'
        else:
            answer+='1'
        q=q-1
    return answer
----------------------------------------------------------------------------------------------------------------------------------------------------------
ㄴ>진법 문제는 자릿수 문제로 이어질 수 있는데, 자리가 언제 바뀌는지 규칙성을 통해 파악할 수 있고 그걸 반복적으로 풀어내면 최적화가 가능하다

풀이 base::
먼저 n을 1,2,4진법을 통해서 표현할 때 자릿수를 찾는다. 3가지 숫자만 쓰는것이라 3과 연관있을것이라는 추측까지는 좋았으나 방향을 처음풀이에서 잘못 잡음
자릿수는 3**0 + ''' + 3**k <= n < 3**0 + ''' + 3**k+1의 범위에 있다 여기서 자릿수는 k+1자릿수가 된다

여기서 가장 중요한 규칙은 예를들어 세자리라면 1,2,4 각각 두자리 수의 케이스를 모두 담는다는 것이다. 즉 두자리 수 케이스가 9개라면 세자리수 케이스는 27개임
즉 두자리 케이스*3이 된다 이걸 반대로 적용해서 찾아나가는 방식을 취한다 예를들어 38의 경우에는 3**0+'''+3**2와 3**0+'''+3**3사이에 존재!
이 자릿수의 경우에는 3의 3승개가 존재하는데, 각각 앞자리가 1,2,4에 따라 3의2승개씩 존재한다 따라서 최적화 기준점 또한 총 3개가 될 수 있는데,
3**0+'''+3**2에 해당하능 13과 총 9개씩 항이 존재하므로 13+3**2인 22 그리고 13+3**2+3**2인 31이 있다.
기준점을 찾으면, 이 기준점을 다시 기준으로해서 반복적으로 3**2끼리 존재하던 것에서 또 찾아나갈 수 있는데 이또한 1,2,4로 나뉘어진다 계속 반복점을 찾아나가는 연산을 하면
연산 수가 많아봐야 14번정도로 5억개의 숫자를 모두 판별할 수 있다
    
#####다른 사람의 풀이
def change124(n):
    num = ['1','2','4']
    answer = ""


    while n > 0:
        n -= 1
        answer = num[n % 3] + answer
        n //= 3

    return answer
    
기가 막히게 품.. ::::: 3번씩 순환하니까 몫과 나머지로....



4.
----------------------------------------------------------------------------------------------------------------------------------------------------------
양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.
수	비트	다른 비트의 개수
2	000...0010	
3	000...0011	1
f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
수	비트	다른 비트의 개수
7	000...0111	
8	000...1000	4
9	000...1001	3
10	000...1010	3
11	000...1011	2
정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ numbers의 길이 ≤ 100,000
0 ≤ numbers의 모든 수 ≤ 1015
입출력 예
numbers	result
[2,7]	[3,11]
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.
----------------------------------------------------------------------------------------------------------------------------------------------------------

첫 번째 풀이 -- TC 10,11 실패 - 시간초과

def solution(numbers):
    answer = []
    def lloop(p):
        k=0
        while 2**k <= p:
            k+=1
        return k-1
    
    for n in numbers:
        if n%2 == 0:
            answer.append(n+1)
        else:
            #최초의 최대치
            max=lloop(n)
            p=max
            m=n
            while p>0:
                m=m-(2**p)
                if p-1!=lloop(m):
                    max=lloop(m)
                    p=max
                else:
                    p-=1
            answer.append(n+(2**max))
    return answer
    ----------------------------------------------------------------------------------------------------------------------------------------------------------
