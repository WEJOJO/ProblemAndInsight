----------------------------------------CodeUp-2001--------------------------------------------------------------------------------
min=2001
min2=2001

for i in range(3):
    k=int(input())
    if k <= min:
        min=k

for j in range(2):
    k=int(input())
    if k<min2:
        min2=k


answer=format((min+min2)*1.1,'.1f')

print(answer)

----------------------------------------CodeUp-3120--------------------------------------------------------------------------------

a,b=input().split()
a=int(a)
b=int(b)

l=abs(a-b) #차이

#아래에서 제일 작은 값을 다시 나머지의 값으로 가져온다 0<=40
cnt=0
min=41
while l!=0:
    if abs(l-10) <= min:
        min=abs(l-10)
    if abs(l-5) <=min:
        min=abs(l-5)
    if abs(l-1) <=min:
        min=abs(l-1)
    l=min
    cnt+=1

print(cnt)



----------------------------------------CodeUp-3321--------------------------------------------------------------------------------

#1 도우의 달러별 효율성
#2 도우보다 효율이 좋은 것만 배열에 오름차순 정렬 100개니까 고급정렬알고리즘은 필요없다 (버블,삽입,내장함수,퀵,병합,힙,계수)
# 100+내장함수로 정렬하자
#도우만 있는게 나은것을 포함해서 순서대로 더한 뒤의 달러당 효율이 큰것이 나올때 까지 찾아나간다. 더 작은게 발견되거나 배열의 끝이면 스톱
 
n=int(input()) #토핑 종류 수
a,b=input().split() #price of dow // top
 
a=int(a)
b=int(b)
 
c=int(input()) #kcal of dow
 
dolPerdow = float(format(c/a,".1f")) #보다 나은 정확성을 위해서..
 
L=[]
 
#배열에 유용한 것만 다 받아 옴
for k in range(n): #0~2까지
    s=int(input())
    if float(format(s/b,".1f")) >= dolPerdow:
        L.append(s)
 
L.sort(reverse=True) #내림차순 정렬 >> 100개라 전혀 문제없음
 
#ex  L = [400, 200, 100 ''' ]
max=dolPerdow
#분모의 총합=가격의 총합
mm=a
#분자의 총합=칼로리의 총합
ss=c
i=0
while i<len(L):
    if float(format((ss+L[i])/(mm+(i+1)*b),".1f")) >= max:
        ss+=L[i]
        max=float(format(ss/(mm+(i+1)*b),".1f"))
    else:
        break
    i+=1
 
max=int(max)
print(max)
 
