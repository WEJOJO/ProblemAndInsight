:::그리디 기법은 구현은 상대적으로 쉽다. 다만 절대 만만하지가 않다. 개인적으로 제일 어려운 알고리즘이라고 생각된다.
이유는, 언제 그리디를 적용하면 좋을지 판단하는 부분이 중요하기 때문.

1. 그리디는 완전탐색과 유사한 것처럼 보이는 문제가 있을 수 있다. 코드업-2001
2. 숫자가 여럿 있는 경우 마치 몫과 나머지인 척 할수도 있다. 코드업 - 3120 ::: 그리가 만만치 않은 이유


------------------------------------------------CodeUp - 2001------------------------------------------------
파파 파스타 가게는 점심 추천 파스타와 생과일 쥬스 세트 메뉴가 인기가 좋다.
이 세트 메뉴를 주문하면 그 날의 3 종류의 파스타와 2 종류의 생과일 쥬스에서 하나씩 선택한다.
파스타와 생과일 쥬스의 가격 합계에서 10%를 더한 금액이 대금된다.
어느 날의 파스타와 생과일 쥬스의 가격이 주어 졌을 때, 그 날 세트 메뉴의 대금의 최소값을 구하는 프로그램을 작성하라.


입력
입력은 5 행으로 이루어지며, 한 줄에 하나씩 양의 정수가 적혀있다.
1행의 정수는 첫 번째 파스타 가격이다.
2행의 정수는 두 번째 파스타 가격이다.
3행의 정수는 세 번째 파스타 가격이다.
4행의 정수는 첫 번째 생과일 쥬스 가격이다.
5행의 정수는 두 번째 생과일 쥬스의 가격이다.
(모든 파스타와 생과일 쥬스의 가격은 100 원이상 2000원 이하이다.)
800
700
900
198
330


출력
그날 세트 메뉴의 최소 대금을 소수 첫째자리까지 출력하시오.
987.8

:::
어떻게 보면 모든 조합의 완전탐색을 요하는 문제라서 그리드라 눈치채기 어려우나,
문제를 쥬스/파스타로 쪼갤수 있다는 점
쪼갠것 끼리 더해도 최종값에 영향을 주지 않는 다는 점에서
완전탐색이아니라, 그리드기법으로 풀 수 있다!
ㄴ>:::그리드는 완전 탐색기법이랑 헷갈리게 보일 수 있을 것같음

------------------------------------------------CodeUp-3120------------------------------------------------
::깨달음을 준 문제 -> 선형적인 최적해를 찾을 때 반드시 지나치지 말아야한다는 고정관념을 깨주었다... 이런 부분도 생각할 줄 알아야 한다
문제
컴퓨터실에서 수업 중인 정보 선생님은 냉난방기의 온도를 조절하려고 한다.
냉난방기가 멀리 있어서 리모컨으로 조작하려고 하는데, 리모컨의 온도 조절 버튼은 다음과 같다.
1) 온도를 1도 올리는 버튼
2) 온도를 1도 내리는 버튼
3) 온도를 5도 올리는 버튼
4) 온도를 5도 내리는 버튼
5) 온도를 10도 올리는 버튼
6) 온도를 10도 내리는 버튼
이와 같이 총 6개의 버튼으로 목표 온도를 조절해야 한다.
현재 설정 온도와 변경하고자하는 목표 온도가 주어지면 이 버튼들을 이용하여 목표 온도로 변경하고자 한다.
이 때 버튼 누름의 최소 횟수를 구하시오.
예를 들어, 7도에서 34도로 변경하는 경우,
7 -> 17 -> 27 -> 32 -> 33 -> 34
이렇게 총 5번 누르면 된다.


입력
현재 온도a 와 목표 온도b가 입력된다. ( 0 <= a , b <= 40 )
7 34

출력
최소한의 버튼 사용으로 목표온도가 되는 버튼의 횟수를 출력한다.

단순히 제일 큰 값에서 깎아 나가면 되는 줄 알았는데 생각해보니... 22 3 > -10을 두번해서 더 작게만들었다가 3으로 하면되네...
내 생각 : 22 3 총 6회 였음 (-10”1 -5”1 -1”4) >>>> 잘 생각해보면 3도로 가는데 1도든 2도든으로 갔다가 가도 된다.. 
매 순간 최단거리를 택하는 방식으로 결정
7 > 34 : 일반적 케이스
22 > 3 : 예외케이스
27 > 3 : 그리디로 풀게 되는 이유 
>> 항상 1,5,10 과의 거리중에서 가장 짧아지는 거리를 택한다
:::선형적 최단거리 찾을 때, 지나쳤다가 가는 방법도 있다는 유연성을 가져야함

------------------------------------------------CodeUp-3321------------------------------------------------
문제
vega 선생님은 Miss 피자 가게의 단골 손님이다.
그는 이번 달부터 절약 생활을 시작했다.
그래서 그는 피자 가게에서 주문할 수 있는 피자 중 1 달러 당 열량이 최대가 되는 피자를 주문하고 싶어한다.
이러한 피자를 "최고의 피자"라고 부르기로 하자.
"최고의 피자"는 1종류가 아니다.
Miss 피자는 N 종류의 토핑에서 여러 종류를 자유롭게 선택하여, 도우 위에 올려 주문할 수있다.
같은 토핑을 2 개 이상 올릴 수 없다.
도우에 토핑을 하나도 하지 않은  피자도 주문할 수있다.
도우의 가격은 A 달러이며, 토핑의 가격은 모두 B 달러이다.
실제 피자 가격은 도우의 가격과 토핑 가격의 합계이다.
즉, 토핑을 k 종류 (0 ≦ k ≦ N) 한 피자의 가격은 A + k × B 원이다.
피자 전체의 칼로리는 도우 열량과 토핑 칼로리의 합계이다.
도우의 가격과 토핑의 가격, 그리고 도우와 각 토핑 열량 값이 주어 졌을 때, "최고의 피자"의 1 달러 당 열량의 수를 구하는 프로그램을 작성하시오.

입력
첫 번째 줄에는 토핑 종류 수를 나타내는 하나의 정수 N (1 ≦ N ≦ 100)이 입력된다.
두 번째 줄에는 두 개의 정수 A, B (1 ≦ A ≦ 1000,1 ≦ B ≦ 1000)가 공백을 구분으로 입력된다. A는 도우의 가격, B는 토핑의 가격을 나타낸다.
세 번째 줄에는 도우의 칼로리를 나타내는 정수 C (1 ≦ C ≦ 10000)가 입력된다.
3 + i 행 (1 ≦ i ≦ N)는 i 번째의 토핑 칼로리 수를 나타내는 정수 Di (1 ≦ Di ≦ 10,000)가 입력된다.
3
12 2
200
50
300
100

출력
"최고의 피자" 1 달러 당 열량의 수를 소수점 이하는 버리고 정수로 출력한다.
37

:::
달러당 칼로리가 도우보다 큰 것만 넣는다고 만사가 아니고 조합을 결국 전문탐색해야 하는가? 근데 100!이라 1억연산 이상임...
완전탐색은 사실상 1초내에 불가한 것같아보이는데...
가장 효율이 좋은것부터 조합해나가서 더 안좋은게 나오지 않는 한 계속 진행하도록
정렬을 한 뒤에 계속 진행해나가보자...>>> 정답
문제는 풀었지만 그리디라는 것으로 알지 못했더라면??? 맞추지 못하였을 것이다.
>>> 결국 그리디는 사용조건을 눈치채는 게 실력인데, 조건에 대한 블로그 뒤져보자.....



----------프로그래머스 큰 수 만들기

문제
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

제한 조건
number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
k는 1 이상 number의 자릿수 미만인 자연수입니다.


----
k의 숫자만큼의 범위 내에서 가장 큰 수를 가져오면 된다는 생각
ㄴ> 여기서도 한 번 더 생각했으면 좋았을 것 같다. (다른 사람의 풀이에서는 언제나 앞에 오는 숫자가 뒤에오는 숫자들보다 크면 된다는 생각으로 풀면 스택을 떠올렸을 가능성이라도 있었을 것.)

어쨌던 그냥 진행하였고,
1. k까지 넘버배열을 자르고
2. max를 찾고
3. max와 뒤의 값을 비교하는 방법으로 진행하였다
4. max < number[st+k] >>> k를 0으로 만들고 그 뒷 배열부터 싹 다 더해서 answer+=로 리턴
5. max >= number[st+k] >>> max이외의 값들은 다 지우고 k에서 차감하고 맥스값들은 answer+= 반복리턴

여기서 max를 계속 찾을때 만약 

-시행착오
그 다음 그냥 max를 찾는 내장함수와 인덱스를 찾아서 연산하는 방법을 취했으나, 이러면 k가 9만 9천이고 max가 항상 맨 앞에 있으면
n*n연산으로 max값 찾는데만 시간을 엄청 쓴다

-시행 착오 이후의 사고 과정
테스트 케이스 10 시간초과 이후
2차원 배열에서 각 인덱스를 저장하고 범위내에 존재한다면 9부터 0까지 꺼내서 쓰는 방법을 사용하면 배열 저장에n번, 역정렬에 logN, 각 수별로 인덱스 따지는 n번의 연산
총 2n+logn (N)연산으로 끝낼 수 있다.

이후 케이스8에서 에러가 났는데, 그건 0을 배제했기 때문...>>> 다시 문제를 읽으면서 보니 0을 배제해서는 안되었던 것. 항상 0이 문제가 되는 경우가 많았다.
정렬문제에서도 00을 놓쳤던 것을 기억하라

시행착오로 배운 점 :::
바킹독 강의에서와 마찬가지로 알고리즘을 짤 때는 연산수를 항상 고려하면서 해야한다.
그걸 고려하지 않고 짜버리니까 케이스10에서 시간초과가 나서 결국 먼 길을 돌아왔다.


-다른 사람의 풀이로 배운 점
::::: 스택으로 푼 문제를 보았는데, 스택으로 볼 수 있는 눈을 키워야 한다.
"언제나 먼저 오는 수가 더 크면 된다">>> 이런 식의 우선순위 구조는 스택으로 표현할 수 있다. 중위표기법과 매우 유사한 방식의 문제풀이
문제를 보고 위와 같은 문장을 느낄 수 있는 것이 실력이 될 것 같음.



